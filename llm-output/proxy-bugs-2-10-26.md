# Proxy Package Bug Report

## 1. ~~LOGIC ERROR: Consolidated Agent Silently Dropped in addPath()~~ FIXED

**File**: `src/main/kotlin/io/prometheus/proxy/ProxyPathManager.kt`
**Lines**: 74-79
**Severity**: ~~HIGH~~
**Status**: FIXED — The `else` clause was removed so `agentInfo.agentContexts += agentContext` (line 72) now executes
unconditionally. Consolidated agents are always added to the list regardless of consolidation type mismatch; the warning
is still logged.

~~When a consolidated agent attempts to register a path that already exists with a different consolidation type, a
warning is logged but no action is taken. The `else` clause on line 78 only executes when the consolidated flags match,
adding the agent to the list. When they mismatch, the agent is silently dropped.~~

```kotlin
if (agentContext.consolidated != agentInfo.isConsolidated)
  logger.warn { "Mismatch of agent context types: ..." }
else
  agentInfo.agentContexts += agentContext  // Only adds when consolidated matches
```

~~**Impact**: Consolidated agents may not be properly registered when there's a consolidation type mismatch, silently
failing without notification to the caller.~~

---

## 2. ~~RACE CONDITION: getAgentContextInfo() Returns Mutable List~~ FIXED

**File**: `src/main/kotlin/io/prometheus/proxy/ProxyPathManager.kt`
**Lines**: 48-53
**Severity**: ~~MEDIUM~~
**Status**: FIXED — Changed `AgentContextInfo.agentContexts` from `MutableList<AgentContext>` to `List<AgentContext>`
and `getAgentContextInfo()` now uses `toList()` instead of `toMutableList()`. Callers can no longer mutate the returned
snapshot. Internal mutation sites within `ProxyPathManager` (all guarded by `synchronized(pathMap)`) cast to
`MutableList` as needed.

~~The method returns a newly created `AgentContextInfo` with a shallow copy of the agent contexts list
via `toMutableList()`. While the copy is created inside a `synchronized` block, the returned list contains references
to `AgentContext` objects that can be modified concurrently by other threads. This creates a time-of-check-time-of-use (
TOCTOU) issue where the returned agent contexts may become invalid between retrieval and use.~~

---

## 3. ~~RACE CONDITION: pathMapSize Property Unsynchronized~~ FIXED

**File**: `src/main/kotlin/io/prometheus/proxy/ProxyPathManager.kt`
**Lines**: 55-56
**Severity**: ~~MEDIUM~~
**Status**: FIXED — `pathMapSize` now uses `synchronized(pathMap) { pathMap.size }`

~~The `pathMapSize` property directly accesses `pathMap.size` without synchronization, while all other methods that
access `pathMap` use `synchronized(pathMap)`. This can return stale or inconsistent values during concurrent
modifications.~~

```kotlin
val pathMapSize: Int
get() = pathMap.size  // No synchronization!
```

---

## 4. ~~RESOURCE LEAK: Channel in ScrapeRequestWrapper Never Closed on Timeout~~ FIXED

**File**: `src/main/kotlin/io/prometheus/proxy/ScrapeRequestWrapper.kt`
**Lines**: 46, 84-88
**Severity**: ~~HIGH~~
**Status**: FIXED — A `closeChannel()` method was added to `ScrapeRequestWrapper` and is now called in the `finally`
block of `submitScrapeRequest()` in `ProxyHttpRoutes.kt`

~~The `completeChannel` (line 46) is created as a `Channel<Boolean>()` but is only closed when `markComplete()` is
called. If the scrape request times out in `ProxyHttpRoutes.submitScrapeRequest()` (line 203-210), `markComplete()` is
never called and the channel is never closed, leading to a resource leak.~~

~~The `finally` block in `submitScrapeRequest()` removes the request from the map but does not close the channel.~~

---

## 5. ~~DATA RACE: Chunked Context Operations Without Synchronization~~ NOT A BUG

**File**: `src/main/kotlin/io/prometheus/proxy/ProxyServiceImpl.kt`
**Lines**: 186-236
**Severity**: ~~CRITICAL~~
**Status**: NOT A BUG — The described race condition cannot occur in practice for three reasons:

1. `chunkedContextMap` is a `ConcurrentHashMap` (`AgentContextManager.kt:33`), so individual put/get/remove operations
   are thread-safe
2. `scrapeId`s are globally unique, generated by `AtomicLong.fetchAndIncrement()` (`ScrapeRequestWrapper.kt:51,90`), so
   different gRPC streams never operate on the same key
3. Within a single gRPC stream, `Flow.collect` processes items sequentially, so header→chunk→summary for a given
   scrapeId cannot interleave

~~The `chunkedContextMap` is accessed without synchronization in `writeChunkedResponsesToProxy`. Multiple concurrent
gRPC streams from different agents could simultaneously:~~
~~- Write to `chunkedContextMap[scrapeId]` (line 195)~~
~~- Read from `chunkedContextMap[chunkScrapeId]` (line 202)~~
~~- Remove from `chunkedContextMap.remove(summaryScrapeId)` (line 211)~~

~~This creates race conditions where:~~
~~1. A chunk could be processed while another stream is setting the header for the same scrapeId~~
~~2. The summary could remove the context while a chunk is being applied~~

~~**Impact**: Lost updates, null pointer exceptions (`check()` failures), or corrupted chunked responses when multiple
agents send chunks concurrently.~~

---

## 6. ~~NPE RISK: removeFromPathManager() Accessing Null agentContext~~ FIXED

**File**: `src/main/kotlin/io/prometheus/proxy/ProxyPathManager.kt`
**Lines**: 161-172
**Severity**: ~~MEDIUM~~
**Status**: FIXED — A null check with early return was added (lines 141-143). If `getAgentContext()` returns null, a
warning is logged and the method returns, so `agentContext.desc` is only reachable when non-null.

~~In the `removeFromPathManager()` method, the `agentContext` variable is used outside the `synchronized` block but
depends on lookup logic inside. If the agent context cannot be found, accessing `agentContext.desc` outside the
synchronized block can cause a `NullPointerException`.~~

---

## 7. ~~MISSING SYNCHRONIZATION: AgentContextCleanupService Iteration~~ FIXED

**File**: `src/main/kotlin/io/prometheus/proxy/AgentContextCleanupService.kt`
**Lines**: 47
**Severity**: ~~MEDIUM~~
**Status**: FIXED — The cleanup service now calls `proxy.agentContextManager.findStaleAgents()` (line 45) which returns
a snapshot list, rather than directly iterating over the live `agentContextMap`.

~~The cleanup service iterates over `agentContextManager.agentContextMap` to find agents to evict.
While `ConcurrentHashMap` allows concurrent iteration, entries can be added or removed during the filter operation.
Agents that become inactive during iteration might be missed, and agents that were already removed could still appear in
the eviction list.~~

---

## 8. ~~LOGIC/CLARITY: ScrapeRequestWrapper.suspendUntilComplete() Inverted Logic~~ FIXED

**File**: `src/main/kotlin/io/prometheus/proxy/ScrapeRequestWrapper.kt`
**Lines**: 74-83
**Severity**: ~~LOW~~
**Status**: FIXED — Renamed `suspendUntilComplete()` to `awaitCompleted()`. The call site
`while (!scrapeRequest.awaitCompleted(checkTime))` now reads naturally as "while not yet completed," which is a standard
pattern (like `Deferred.await()`).

~~The `suspendUntilComplete` method uses `withTimeoutOrNull` which returns null on timeout. The result is checked
with `.isNotNull()`, returning `true` if completed, `false` if timed out. The calling code in ProxyHttpRoutes (line 203)
uses `!suspendUntilComplete()` to detect timeout. While functionally correct, this double-negation pattern is confusing
and error-prone for future maintenance.~~

---

## 9. ~~DESIGN ISSUE: Unnecessary require() in connectAgentWithTransportFilterDisabled()~~ FIXED

**File**: `src/main/kotlin/io/prometheus/proxy/ProxyServiceImpl.kt`
**Lines**: 79-84
**Severity**: ~~LOW~~
**Status**: FIXED — Removed the meaningless `require(agentContext.agentId.isNotEmpty())` check (agentId is always
non-empty since it's assigned via `AtomicLong.incrementAndFetch().toString()` at construction). Moved `addAgentContext`
after the `agentInfo` block is built using `.also {}`, so the context is only visible to other threads after it's fully
set up.

~~Creates a new `AgentContext` and immediately adds it to the manager, then validates that `agentId` is not empty.
Since `agentId` is assigned in `AgentContext.init{}` via `AtomicLong`, it can never be empty. The `require()` check is
defensive but meaningless, and the early `addAgentContext` call means a partially-setup context is visible to other
threads before validation completes.~~

---

## 10. ~~RESOURCE LEAK: Scrape Request Channel on Map Removal Failure~~ FIXED

**File**: `src/main/kotlin/io/prometheus/proxy/ProxyHttpRoutes.kt`
**Lines**: 199-216
**Severity**: ~~HIGH~~
**Status**: FIXED — `closeChannel()` is now called before map removal in the `finally` block, ensuring the channel is
always closed regardless of map removal outcome

~~In the `finally` block of `submitScrapeRequest()`, if `removeFromScrapeRequestMap` returns null (entry was already
removed), an error is logged but the `completeChannel` inside the `ScrapeRequestWrapper` is never closed. Combined with
Issue #4, this creates a consistent resource leak path for timed-out or failed requests.~~

---

## 11. ~~TOCTOU RACE: allPaths Property~~ FIXED

**File**: `src/main/kotlin/io/prometheus/proxy/ProxyPathManager.kt`
**Lines**: 59
**Severity**: ~~MEDIUM~~
**Status**: FIXED — Added `allPathContextInfos()` which atomically snapshots both paths and their `AgentContextInfo` in
a single `synchronized(pathMap)` block. Updated `Proxy.buildServiceDiscoveryJson()` to use it instead of the separate
`allPaths` + `getAgentContextInfo(path)` pattern, eliminating the TOCTOU window where a path could be removed between
key enumeration and info lookup.

~~The `allPaths` property creates a snapshot of keys inside a `synchronized` block, but the snapshot is immediately
stale. Callers that iterate over the returned list and then look up paths may find that paths no longer exist, or miss
paths that were added after the snapshot was taken.~~

```kotlin
val allPaths: List<String>
get() = synchronized(pathMap) { pathMap.keys.toList() }
```

---

## Summary

| #  | Severity     | File                          | Lines   | Category       | Status        |
|----|--------------|-------------------------------|---------|----------------|---------------|
| 1  | ~~HIGH~~     | ProxyPathManager.kt           | 74-79   | Logic Error    | **FIXED**     |
| 2  | ~~MEDIUM~~   | ProxyPathManager.kt           | 48-53   | Race Condition | **FIXED**     |
| 3  | ~~MEDIUM~~   | ProxyPathManager.kt           | 55-56   | Race Condition | **FIXED**     |
| 4  | ~~HIGH~~     | ScrapeRequestWrapper.kt       | 46      | Resource Leak  | **FIXED**     |
| 5  | ~~CRITICAL~~ | ProxyServiceImpl.kt           | 186-236 | Data Race      | **NOT A BUG** |
| 6  | ~~MEDIUM~~   | ProxyPathManager.kt           | 161-172 | NPE Risk       | **FIXED**     |
| 7  | ~~MEDIUM~~   | AgentContextCleanupService.kt | 47      | Missing Sync   | **FIXED**     |
| 8  | ~~LOW~~      | ScrapeRequestWrapper.kt       | 74-83   | Logic/Clarity  | **FIXED**     |
| 9  | ~~LOW~~      | ProxyServiceImpl.kt           | 79-84   | Design Issue   | **FIXED**     |
| 10 | ~~HIGH~~     | ProxyHttpRoutes.kt            | 199-216 | Resource Leak  | **FIXED**     |
| 11 | ~~MEDIUM~~   | ProxyPathManager.kt           | 59      | TOCTOU Race    | **FIXED**     |
